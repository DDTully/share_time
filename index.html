<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>Share Your Time</title>
  <style>
    :root {
      --bg: #f4f4f9;
      --card-bg: #fff;
      --text: #333;
      --input-border: #ccc;
      --btn-bg: #6200ee;
      --btn-text: #fff;
      --btn-hover: #3700b3;
      --btn-next: #03dac6;
      --btn-pause: #fbbc04;
      --btn-restart: #b00020;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        /* GitHub Dark Mode Colors */
        --bg: #0d1117;
        --card-bg: #161b22;
        --text: #c9d1d9;
        --input-border: #30363d;
        --btn-bg: #238636;      /* Green success */
        --btn-text: #ffffff;
        --btn-hover: #2ea043;
        --btn-next: #0969da;    /* Blue primary */
        --btn-pause: #dbab09;   /* Yellow warning */
        --btn-restart: #cf222e; /* Red danger */
      }
    }
    body { font-family: Arial, sans-serif; background: var(--bg); color: var(--text); margin: 0; padding: 0; }
    #setup {
      max-width: 500px;
      margin: 1rem auto;
      background: var(--card-bg);
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      padding: 1rem;
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
    }
    #setup button {
      width: 100%;
      padding: 0.75rem;
      margin: 0.5rem 0;
      font-size: 1rem;
      border-radius: 4px;
      border: none;
      background: var(--btn-next);
      color: var(--btn-text);
      cursor: pointer;
    }
    #app { max-width: 500px; margin: 1rem auto; background: var(--card-bg); border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 1rem; display: block; }
    label { display: block; margin: 0.5rem 0; font-size: 1rem; }
    input, button { width: 100%; padding: 0.75rem; margin: 0.5rem 0; font-size: 1rem; box-sizing: border-box; border-radius: 4px; border: 1px solid var(--input-border); }
    button { background: var(--btn-bg); color: var(--btn-text); border: none; cursor: pointer; }
    button:hover { background: var(--btn-hover); }
    button#finishBtn { background: var(--btn-next); color: var(--btn-text); }
    button#pauseBtn { background: var(--btn-pause); color: var(--btn-text); }
    button#restartBtn { background: var(--btn-restart); color: var(--btn-text); }
    #info p { display: grid; grid-template-columns: 1fr auto; margin: 0.5rem 0; }
    #controls { display: flex; justify-content: space-between; gap: 0.5rem; margin: 1rem 0; }
    #controls button { flex: 1; margin: 0; }
    #remainingList h3 { margin-top: 1rem; }
    #remainingList ul { list-style: none; padding: 0; }
    #remainingList li { padding: 0.25rem 0; border-bottom: 1px solid #eee; }
    @media (min-width: 600px) {
      input, button { width: auto; display: inline-block; margin-right: 0.5rem; }
      #setup, #app { padding: 2rem; }
    }
    /* Stack label text above its input in setup */
    #setup label {
      display: flex;
      flex-direction: column;
    }
    /* Large centered main timer above the info panel */
    #mainTimer { text-align: center; font-size: 3rem; margin: 0.5rem 0; }
  </style>
</head>
<body>
  <div id="setup">
    <label>Target time (HH:MM): <input id="timeInput" type="time" value="19:58"></label>
    <label>Number of people: <input id="peopleInput" type="number" min="1" value="3"></label>
    <label>Buffer between (seconds): <input id="bufferInput" type="number" min="0" value="10"></label>
    <button id="startBtn">Start</button>
  </div>
  <div id="app" style="display:none;">
    <!-- Main large timer -->
    <div id="mainTimer"><p><span id="mainTimeLeft"></span></p></div>
    <div id="info">
      <p>Current Person: <span id="currentPerson"></span></p>
      <p>People Remaining: <span id="peopleRemaining"></span></p>
      <p>Time Left: <span id="timeLeft"></span></p>
      <p>Behind Schedule: <span id="behindTime">00:00</span></p>
      <p>Current Time: <span id="currentTime"></span></p>
      <p>Target Time: <span id="targetTimeDisplay"></span></p>
    </div>
    <div id="controls">
      <button id="finishBtn">Next</button>
      <button id="pauseBtn">Pause</button>
      <button id="restartBtn">Restart</button>
    </div>
    <div id="remainingList">
      <h3>Remaining People:</h3>
      <ul id="peopleList"></ul>
    </div>
  </div>
  <!-- Using Howler.js for all playback -->
  <script src="https://cdn.jsdelivr.net/npm/howler/dist/howler.min.js"></script>
  <script>
    let persons = [];
    let timerInterval = null;
    let bufferSec = 0;
    let behindSchedule = 0;
    let endTime = null;
    let ttsInterval = false;
    let ttsTimeout = null;
    // Howler.js alarm and announcement setup
    const alarmSound = new Howl({ src:['assets/alarm.mp3'], loop:true, volume:0.5, preload:true, html5:false, mobileAutoEnable:true });
    // Preload announcement sounds
    const prefixSounds = {
      many: new Howl({src:['assets/more_than_1_left_prefix.mp3'], preload:true, html5:false, mobileAutoEnable:true}),
      one:  new Howl({src:['assets/1_left_prefix.mp3'], preload:true, html5:false, mobileAutoEnable:true}),
      zero: new Howl({src:['assets/0_left_prefix.mp3'], preload:true, html5:false, mobileAutoEnable:true})
    };
    const suffixSounds = {
      many: new Howl({src:['assets/more_than_1_left_suffix.mp3'], preload:true, html5:false, mobileAutoEnable:true}),
      one:  new Howl({src:['assets/1_left_suffix.mp3'], preload:true, html5:false, mobileAutoEnable:true}),
      zero: new Howl({src:['assets/0_left_suffix.mp3'], preload:true, html5:false, mobileAutoEnable:true})
    };
    const digitSounds = {};
    // stop only announcement sounds
    function stopAnnouncements() {
      // clear any scheduled repeat
      if (ttsTimeout) { clearTimeout(ttsTimeout); ttsTimeout = null; }
      ttsInterval = false;
      // stop any ongoing announcement sounds
      Object.values(prefixSounds).forEach(h => h.stop());
      Object.values(digitSounds).forEach(h => h.stop());
      Object.values(suffixSounds).forEach(h => h.stop());
    }
    // stop both announcements and alarm
    function stopAllSounds() {
      stopAnnouncements();
      if (alarmSound.playing()) alarmSound.stop();
    }
    // play prefix–number–suffix in sequence and repeat while active
    function playCountAnnouncement(count) {
      const prefix = count > 1 ? prefixSounds.many : (count === 1 ? prefixSounds.one : prefixSounds.zero);
      const idx = Math.min(count, 100);
      const digit = digitSounds[idx] || digitSounds[0];
      const suffix = count > 1 ? suffixSounds.many : (count === 1 ? suffixSounds.one : suffixSounds.zero);
      // chain playback
      const pid = prefix.play();
      prefix.once('end', () => {
        const did = digit.play();
        digit.once('end', () => {
          const sid = suffix.play();
          suffix.once('end', () => {
            // after suffix, repeat if still active
            if (ttsInterval) {
              ttsTimeout = setTimeout(() => playCountAnnouncement(count), 5000);
            }
          }, sid);
        }, did);
      }, pid);
    }

    function formatTime(seconds) {
      const neg = seconds < 0;
      const s = Math.ceil(Math.abs(seconds));
      const m = Math.floor(s / 60);
      const sec = s % 60;
      const formatted = `${m.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
      return neg ? `-${formatted}` : formatted;
    }

    function updateList() {
      const list = document.getElementById('peopleList');
      list.innerHTML = '';
      persons.slice(1).forEach(p => {
        const li = document.createElement('li');
        li.textContent = `Person ${p.id}: ${formatTime(p.timeLeft)}`;
        list.appendChild(li);
      });
    }

    function updateTimeLeft() {
      const formatted = formatTime(persons[0].timeLeft);
      // update both small and main displays
      document.getElementById('timeLeft').textContent = formatted;
      const mainEl = document.getElementById('mainTimeLeft');
      if (mainEl) mainEl.textContent = formatted;
    }

    function nextPerson() {
      if (timerInterval) clearInterval(timerInterval);
      // reset announcement flag for new person
      ttsInterval = false;
      if (persons.length === 0) {
        document.getElementById('info').innerHTML = '<p>All done!</p>';
        document.getElementById('finishBtn').disabled = true;
        return;
      }
      const current = persons[0];
      document.getElementById('currentPerson').textContent = current.id;
      document.getElementById('peopleRemaining').textContent = Math.max(persons.length - 1, 0);
      updateList();
      updateTimeLeft();
      timerInterval = setInterval(() => {
        current.timeLeft -= 1;
        updateTimeLeft();
        // play alarm via Howler
        if (current.timeLeft <= 0 && !alarmSound.playing()) {
          alarmSound.play();
        }
        // count announcements via Howler
        if (current.timeLeft <= -5) {
          // start repeating announcements once
          if (!ttsInterval) {
            ttsInterval = true;
            const remaining = persons.length - 1;
            playCountAnnouncement(remaining);
          }
        }
      }, 1000);
    }

    function handleFinish() {
      // stop announcements and alarm
      stopAllSounds();
      if (timerInterval) clearInterval(timerInterval);
      const current = persons.shift();
      let remainder = current.timeLeft;
      if (remainder > 0 && behindSchedule > 0) {
        const reduce = Math.min(remainder, behindSchedule);
        behindSchedule -= reduce;
        document.getElementById('behindTime').textContent = formatTime(behindSchedule);
        remainder -= reduce;
      } else if (remainder < 0 && remainder < -bufferSec) {
        const penalty = -(remainder + bufferSec);
        behindSchedule += penalty;
        document.getElementById('behindTime').textContent = formatTime(behindSchedule);
      }
      if (persons.length > 0) {
        const now = new Date();
        const totalSecondsLeft = (endTime - now) / 1000;
        const totalBuffer = bufferSec * (persons.length - 1);
        const available = totalSecondsLeft - totalBuffer - behindSchedule;
        const perTime = available / persons.length;
        persons = persons.map(p => ({ id: p.id, timeLeft: perTime }));
        nextPerson();
      } else {
        document.getElementById('info').innerHTML = '<p>All done!</p>';
        document.getElementById('finishBtn').disabled = true;
      }
    }

    function restartGame() {
      // stop announcements and alarm
      stopAllSounds();
      // stop timers, alarms, and speech
      if (timerInterval) clearInterval(timerInterval);
      persons = [];
      behindSchedule = 0;
      // hide the app and show the setup form
      document.getElementById('app').style.display = 'none';
      document.getElementById('setup').style.removeProperty('display');
      // restore the info panel's original structure
      document.getElementById('info').innerHTML = `
        <p>Current Person: <span id="currentPerson"></span></p>
        <p>People Remaining: <span id="peopleRemaining"></span></p>
        <p>Time Left: <span id="timeLeft"></span></p>
        <p>Behind Schedule: <span id="behindTime">00:00</span></p>
        <p>Current Time: <span id="currentTime"></span></p>
        <p>Target Time: <span id="targetTimeDisplay"></span></p>
      `;
      document.getElementById('finishBtn').disabled = false;
      // clear dynamic displays (keeping input values intact)
      document.getElementById('peopleList').innerHTML = '';
      document.getElementById('currentPerson').textContent = '';
      document.getElementById('timeLeft').textContent = '';
      document.getElementById('behindTime').textContent = '00:00';
      document.getElementById('currentTime').textContent = '';
      document.getElementById('targetTimeDisplay').textContent = '';
    }

    function togglePause() {
      const pauseBtn = document.getElementById('pauseBtn');
      if (pauseBtn.textContent === 'Pause') {
        if (timerInterval) clearInterval(timerInterval);
        // pause announcements and alarm
        stopAllSounds();
        pauseBtn.textContent = 'Resume';
      } else {
        const now = new Date();
        const totalSecondsLeft = (endTime - now) / 1000;
        const totalBuffer = bufferSec * (persons.length - 1);
        const availableAll = totalSecondsLeft - totalBuffer - behindSchedule;
        const currentLeft = persons[0].timeLeft;
        const remainingCount = persons.length - 1;
        if (remainingCount > 0) {
          const availableForOthers = availableAll - currentLeft;
          const perTimeForRemaining = availableForOthers / remainingCount;
          for (let i = 1; i < persons.length; i++) {
            persons[i].timeLeft = perTimeForRemaining;
          }
        }
        pauseBtn.textContent = 'Pause';
        nextPerson();
      }
    }

    async function startGame() {
      const targetTimeString = document.getElementById('timeInput').value;
      const count = parseInt(document.getElementById('peopleInput').value);
      // preload digit announcements up to count (max 100)
      const preloadCount = Math.min(count, 100);
      for (let i = 0; i <= preloadCount; i++) {
        digitSounds[i] = new Howl({ src: [`assets/${i}.mp3`], preload: true, html5: false, mobileAutoEnable: true });
      }
      const bufferValue = parseFloat(document.getElementById('bufferInput').value);
      if (isNaN(bufferValue) || bufferValue < 0) {
        alert('Please enter a valid buffer value (>=0)');
        return;
      }
      bufferSec = bufferValue;
      behindSchedule = 0;
      if (!targetTimeString || isNaN(count) || count <= 0) {
        alert('Please enter a valid target time and positive number of people');
        return;
      }
      const [hours, minutes] = targetTimeString.split(':').map(Number);
      const now = new Date();
      let target = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes, 0);
      if (target <= now) target.setDate(target.getDate() + 1);
      endTime = target;
      const totalSeconds = (target - now) / 1000;
      const totalBuffer = bufferSec * (count - 1);
      const usableSeconds = totalSeconds - totalBuffer;
      const perTime = usableSeconds / count;
      persons = [];
      for (let i = 1; i <= count; i++) {
        persons.push({ id: i, timeLeft: perTime });
      }
      document.getElementById('setup').style.display = 'none';
      document.getElementById('app').style.display = 'block';
      document.getElementById('behindTime').textContent = formatTime(behindSchedule);
      document.getElementById('targetTimeDisplay').textContent = endTime.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit', hour12: true });
      const clockOpts = { hour: 'numeric', minute: '2-digit', second: '2-digit', hour12: true };
      document.getElementById('currentTime').textContent = new Date().toLocaleTimeString([], clockOpts);
      nextPerson();
    }

    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('finishBtn').addEventListener('click', handleFinish);
    document.getElementById('restartBtn').addEventListener('click', restartGame);
    document.getElementById('pauseBtn').addEventListener('click', togglePause);
  </script>
</body>
</html> 